{"meta":{"title":"NullOK - Blog","subtitle":"NullPointException","description":"talk is cheap,show me your code.","author":"nullok","url":"http://www.nullok.com","root":"/"},"pages":[{"title":"GitHub Project","date":"2019-12-16T07:20:07.000Z","updated":"2020-01-23T14:18:00.292Z","comments":true,"path":"project/index.html","permalink":"http://www.nullok.com/project/index.html","excerpt":"","text":"#1 大英自主学习刷分 网址：http://shua.nullok.com/ 技术栈：Vue + axios + VantUI #2 社区demo 网址：http://sq.nullok.com/ 源码：https://github.com/nullok/community 技术栈：Springboot + mybatis + layui 描述：半成品，入门springboot的demo"},{"title":"分类","date":"2019-07-19T11:26:11.000Z","updated":"2020-01-23T14:19:33.150Z","comments":true,"path":"categories/index.html","permalink":"http://www.nullok.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-07-19T11:49:32.000Z","updated":"2020-01-23T14:33:07.972Z","comments":true,"path":"about/index.html","permalink":"http://www.nullok.com/about/index.html","excerpt":"","text":"1234567891011121314151617181920212223242526272829&#123; name: &apos;nullok&apos; age: 3, gender: &apos;男&apos;, profession: &apos;code &amp; code&apos;, experience: &apos;0年&apos;, address: &apos;山东滕州&apos;, education: &apos;本科&apos;, github: &apos;https://github.com/nullok&apos;, blog: &apos;https://www.nullok.com/&apos;, email: &apos;nullok@nullok.com&apos;, description: &apos;一枚菜鸡的萌新&apos;, skills: [ [&apos;Html&apos;, &apos;Javascript&apos;, &apos;jCSS&apos;, &apos;ES6&apos;], [&apos;Sass&apos;], [&apos;Git&apos;], [&apos;Vue&apos;], [&apos;antdVue&apos;, &apos;ElementUI&apos;], [&apos;Java&apos;, &apos;python&apos;], [&apos;SpringBoot&apos;] ], devTools: [ [&apos;Visual Studio Code&apos;, &apos;Notepad++&apos;], [&apos;IDEA&apos;,&apos;WebStrom&apos;,&apos;Pycharm&apos;], [&apos;Navicat&apos;], ] &#125;"},{"title":"标签","date":"2019-07-19T11:48:22.000Z","updated":"2020-01-23T14:15:53.395Z","comments":true,"path":"tags/index.html","permalink":"http://www.nullok.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Shiro + Redis自定义session会话管理","slug":"Shiro-Redis自定义session会话管理","date":"2020-01-23T11:54:09.000Z","updated":"2020-01-24T01:55:12.327Z","comments":true,"path":"2020/01/23/Shiro-Redis自定义session会话管理/","link":"","permalink":"http://www.nullok.com/2020/01/23/Shiro-Redis自定义session会话管理/","excerpt":"","text":"此图非常重要！！！镇楼 0x001 重写SessionManagershiro提供了三种默认实现： DefaultSessionManager： 用于java se 环境 ServletContainerSessionManager：默认使用的实现，Servlet容器管理 DefaultWebSessionManager：自己维护 重写SessionManager需要继承DefaultWebSessionManager类 目的：自定义从header中的Authorization获取token 1234567891011121314151617public class CustomSessionManager extends DefaultWebSessionManager &#123; @Override protected Serializable getSessionId(ServletRequest request, ServletResponse response) &#123; String id = WebUtils.toHttp(request).getHeader(\"Authorization\"); if (StringUtils.isEmpty(id)) &#123; // 获取sessionId，id可以自定义 return super.getSessionId(request, response); &#125; else &#123; //返回sessionId；固定套路 request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, \"header\"); request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id); request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE); return id; &#125; &#125;&#125; 0x002 重写SessionDao重写SessionDao 需要实现SessionDAO接口 继承以下子类也可以： 继承AbstractSessionDAO，其实现了基础的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Componentpublic class SelfSessionDao extends AbstractSessionDAO &#123; @Autowired private RedisTemplate&lt;Object,Object&gt; redisTemplate; private final int expire = 30; private final String prefix = \"shiro:session\"; // 创建session，保存到数据库 @Override protected Serializable doCreate(Session session) &#123; Serializable sessionId = generateSessionId(session); // 非常重要，生成id之后 要设置到session实例当中，否则shiro认证不通过 assignSessionId(session, sessionId); System.out.println(\"执行 doCreate\"); redisTemplate.boundValueOps(prefix + sessionId).set(session,expire, TimeUnit.SECONDS); return sessionId; &#125; @Override protected Session doReadSession(Serializable sessionId) &#123; System.out.println(\"执行 doReadSession\"); return (Session) redisTemplate.boundValueOps(prefix + sessionId).get(); &#125; // 每次带token访问api时 都会执行更新session @Override public void update(Session session) throws UnknownSessionException &#123; if (session == null || session.getId() == null) &#123; throw new UnknownSessionException(\"session 或者 session为空\"); &#125; System.out.println(\"执行 update\"); redisTemplate.boundValueOps(prefix + session.getId()).set(session,expire,TimeUnit.SECONDS); &#125; @Override public void delete(Session session) &#123; System.out.println(\"执行 delete\"); redisTemplate.delete(prefix + session.getId()); &#125; @Override public Collection&lt;Session&gt; getActiveSessions() &#123; Set&lt;Object&gt; keys = redisTemplate.keys(prefix); if (keys != null) &#123; return keys.stream().map(key -&gt; &#123; Session session = (Session) redisTemplate.boundValueOps(key).get(); return session; &#125;).collect(Collectors.toList()); &#125; else &#123; return null; &#125; &#125;&#125; 0x003自定义id生成器12345678public class CustomSessionIdGenerator implements SessionIdGenerator &#123; @Override public Serializable generateId(Session session) &#123; //... 生成id逻辑 return id; &#125;&#125; 0x004 配置类12345678910111213141516171819202122@Bean public SecurityManager getSecurityManager(CustomRealm realm,DefaultWebSessionManager defaultWebSessionManager) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(realm); //将自定义的会话管理器注册到安全管理器中 securityManager.setSessionManager(defaultWebSessionManager); //将自定义的redis缓存管理器注册到安全管理器中 securityManager.setCacheManager(selfCacheManager()); return securityManager; &#125;//会话管理器@Bean public DefaultWebSessionManager sessionManager(SelfSessionDao selfSessionDao) &#123; CustomSessionManager sessionManager = new CustomSessionManager(); // 自定义sessionDAO sessionManager.setSessionDAO(selfSessionDao); // 自定义id生成器 selfSessionDao.setSessionIdGenerator(new CustomSessionIdGenerator()); return sessionManager; &#125;","categories":[{"name":"Shiro","slug":"Shiro","permalink":"http://www.nullok.com/categories/Shiro/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://www.nullok.com/tags/Shiro/"}]},{"title":"Ubuntu中docker开启远程模式","slug":"Ubuntu中docker开启远程模式","date":"2020-01-22T09:54:49.000Z","updated":"2020-01-23T14:39:28.637Z","comments":true,"path":"2020/01/22/Ubuntu中docker开启远程模式/","link":"","permalink":"http://www.nullok.com/2020/01/22/Ubuntu中docker开启远程模式/","excerpt":"","text":"0x011vim /lib/systemd/system/docker.service 0x02找到ExecStart,并添加-H tcp://0.0.0.0:2375 12原：ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock 123增加-H tcp://0.0.0.0:2375：ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H fd:// --containerd=/run/containerd/containerd.sock 0x0312systemctl daemon-reload // 加载docker守护线程systemctl restart docker // 重启docker 0x04测试是否成功 1docker -H 127.0.0.1 info 12345678910111213显示信息Client: Debug Mode: falseServer: Containers: 5 Running: 1 Paused: 0 Stopped: 4 Images: 6 Server Version: 19.03.3 Storage Driver: overlay2.......","categories":[{"name":"docker","slug":"docker","permalink":"http://www.nullok.com/categories/docker/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://www.nullok.com/tags/Ubuntu/"},{"name":"docker","slug":"docker","permalink":"http://www.nullok.com/tags/docker/"}]},{"title":"springboot+mybatis配置中遇到的问题","slug":"springboot-mybatis配置中遇到的问题","date":"2019-10-05T13:43:01.000Z","updated":"2020-01-23T14:39:19.595Z","comments":true,"path":"2019/10/05/springboot-mybatis配置中遇到的问题/","link":"","permalink":"http://www.nullok.com/2019/10/05/springboot-mybatis配置中遇到的问题/","excerpt":"","text":"配置数据源123456789101112131415161718192021222324@Configuration@MapperScan(\"cn.ileehan.community.dao\")public class DataSourceConfiguration &#123; @Value(\"$&#123;c3p0.driver&#125;\") private String jdbcDriver; @Value(\"$&#123;c3p0.url&#125;\") private String jdbcUrl; @Value(\"$&#123;c3p0.name&#125;\") private String jdbcUsername; @Value(\"$&#123;c3p0.password&#125;\") private String jdbcPassword; @Bean(name = \"dataSource\") public ComboPooledDataSource createDataSource() throws PropertyVetoException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(jdbcDriver); dataSource.setJdbcUrl(jdbcUrl); dataSource.setUser(jdbcUsername); dataSource.setPassword(jdbcPassword); // 关闭连接之后不自动commit dataSource.setAutoCommitOnClose(false); return dataSource; &#125;&#125; 配置SqlSessionFactoryBean123456789101112131415161718192021222324252627282930313233@Configurationpublic class SessionFactoryConfiguration &#123; @Value(\"$&#123;mapper.xml.config.path&#125;\") private String mapperXMLConfigPath; @Value(\"$&#123;mapper.package.path&#125;\") private String mapperPackagePath; @Value(\"$&#123;mapper.global.config&#125;\") private String globalConfig; @Autowired private DataSource dataSource; @Bean public SqlSessionFactoryBean createSqlSessionFactory() throws IOException &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); // resource查找器可以查找类路径下或文件路径下的资源 PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); // mapperXML文件路径 String packageMapperXMLConfigPath = PathMatchingResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + mapperXMLConfigPath; // mybatis-config.xml路径 String globalConfigPath = PathMatchingResourcePatternResolver.CLASSPATH_URL_PREFIX + globalConfig; // 设置 mapper 对应的 XML 文件的路径 sqlSessionFactoryBean.setMapperLocations(resolver.getResources(packageMapperXMLConfigPath)); // 设置数据源 sqlSessionFactoryBean.setDataSource(dataSource); // 设置 mapper 接口所在的包 sqlSessionFactoryBean.setTypeAliasesPackage(mapperPackagePath); // 设置mybatis-config.xml，否则xml中全局配置将失效 sqlSessionFactoryBean.setConfigLocation(resolver.getResource(globalConfigPath)); return sqlSessionFactoryBean; &#125;&#125; 注意：在使用配置类配置SqlSessionFactoryBean时，要记得设置setConfigLocation #","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.nullok.com/categories/SpringBoot/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://www.nullok.com/tags/笔记/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.nullok.com/tags/SpringBoot/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://www.nullok.com/tags/Mybatis/"}]},{"title":"Struts2.5.x遇到的坑","slug":"Struts2-5-x遇到的坑","date":"2019-07-29T11:55:28.000Z","updated":"2020-01-23T13:51:36.441Z","comments":true,"path":"2019/07/29/Struts2-5-x遇到的坑/","link":"","permalink":"http://www.nullok.com/2019/07/29/Struts2-5-x遇到的坑/","excerpt":"","text":"通配符访问方法，报错404错误找不到页面报错截图 报错内容：There is no Action mapped for namespace [/] and action name [Emp_edit] associated with context path [/demo]. 错误原因：Struts2.5 为了提升安全性，默认开启了Strict Method Invocation（strict-method-invocation） 在SMI开启的情况下，通配符不会匹配所有的方法名，而是会匹配在default-struts.xml文件中global-allowed-methods属性所允许的方法名或者是匹配通过 &lt;allowed-method/&gt;标签来定义的方法名。 解决方法： ​ 方法一 在struts.xml中的package下添加regex:.*，匹配所有。 ​ 方法二 将package标签的属性strict-method-invocation设置为false。 默认全局允许匹配的方法名称： 动态匹配问题官方解释","categories":[{"name":"Struts2","slug":"Struts2","permalink":"http://www.nullok.com/categories/Struts2/"}],"tags":[{"name":"-Struts2 -Java","slug":"Struts2-Java","permalink":"http://www.nullok.com/tags/Struts2-Java/"}]},{"title":"IDEA导入mysql驱动，运行时找不到驱动包解决方案","slug":"IDEA导入mysql驱动，运行时找不到驱动包解决方案","date":"2019-07-23T10:09:13.000Z","updated":"2020-01-23T13:50:53.747Z","comments":true,"path":"2019/07/23/IDEA导入mysql驱动，运行时找不到驱动包解决方案/","link":"","permalink":"http://www.nullok.com/2019/07/23/IDEA导入mysql驱动，运行时找不到驱动包解决方案/","excerpt":"","text":"状况： 驱动导入了。 编译成功，运行报错： 解决办法 在WEB-INF目录下创建lib文件夹，将驱动包放入文件夹，并将lib文件设置为resources 再次添加驱动包就可以了","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://www.nullok.com/categories/Servlet/"}],"tags":[{"name":"-Servlet","slug":"Servlet","permalink":"http://www.nullok.com/tags/Servlet/"}]},{"title":"MyEclipse2017破解方法","slug":"MyEclipse2017破解方法","date":"2019-07-20T13:58:59.000Z","updated":"2020-01-23T13:51:17.247Z","comments":true,"path":"2019/07/20/MyEclipse2017破解方法/","link":"","permalink":"http://www.nullok.com/2019/07/20/MyEclipse2017破解方法/","excerpt":"","text":"方法安装包链接: https://pan.baidu.com/s/139Yc0FYVeKckEfgPMROhkQ 提取码: ilee 破解文件链接: https://pan.baidu.com/s/1eEn8nKAa07nnNnv_U-hnJw 提取码: ilee 首先配置好Java环境。 安装MyEclipse。 在安装最后一步，千万别点那个打开MyEclipse。 关闭安装界面后，把破解文件中的path里的所有文件拷贝进你的安装目录里的plugins，这里提醒你替换，选择替换。 替换完成后，再打开破解文件里myeclipse_keygen文件夹里的crack.bat，如果你发现点开闪退，这是你Java环境没有配置好的原因，去配置好你的Java环境，再运行crack.bat，出来一个界面。上面的空是你的用户名，这里自己起个名就ok，后面那个里面有很多版本，自己选择一个版本。 输好用户名，选择好版本，点一下systemid，再点一下systemid，然后点一下active，然后窗口下方会出现一堆东西例如这些： 12345678LICENSEE JerryLICENSE_KEY WLR8ZO-855555-7653625140119936ACTIVATION_CODE 11dFE23feaa1DBFE147730WLR8ZO-855555-7653625140119936210817ACTIVATION_KEY b5f7219363534b3fe8c02272c4cae4bff6621a5ceab73c4212c7e9e79fcf9ea5a5eedc9552a9901ef542ea90b474a6de64fe91b24b1e899982ff0a0152bb9ebae97efa69edd53ca90ccd85135f17a16571c297be4489108071870bf92d255f8dd95e01806d03727767b09e468dae9ac6c7a324126c026e483d0f20d2a231073d 看到这些，保留这个窗口，打开MyEclipse，打开后，选择active now，输入你的用户名和那个license key，然后，继续激活，选择我已经有激活文件（这里应该是英文，大家自己理解意思哈），输入activation_key下面那一大串的东西，然后激活就OK。 方法来源52破解","categories":[{"name":"工具","slug":"工具","permalink":"http://www.nullok.com/categories/工具/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.nullok.com/tags/Java/"},{"name":"工具","slug":"工具","permalink":"http://www.nullok.com/tags/工具/"}]},{"title":"Java 反射(Reflection) 学习笔记","slug":"java反射学习笔记","date":"2019-07-19T16:10:57.000Z","updated":"2020-01-23T13:51:01.005Z","comments":true,"path":"2019/07/20/java反射学习笔记/","link":"","permalink":"http://www.nullok.com/2019/07/20/java反射学习笔记/","excerpt":"","text":"一、反射概述JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 (网图) 类加载过程： 二、Class类（包含完整的类的结构信息）Class对象由来：将class文件读入内存，并为之创建一个Class对象 Class 没有public 构造器。Class 对象是在加载类时由Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。 每个类（型）都有一个Class对象 Java基本类型和void都对应一个Class对象 每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。 1234567891011121314151617181920212223//每个数组属于被映射为 `Class` 对象的一个类，所有具有相同元素类型和维数的数组都共享该 `Class` 对象public class Demo3 &#123; public static void main(String[] args) &#123; String[] str = new String[3]; String[] str2 = new String[30]; String[][] str3 = new String[3][]; int[] in = new int[3]; int[][] in2 = new int[3][]; System.out.println(\"String一维数组:\"+str.getClass().hashCode()); System.out.println(\"String一维数组（30）:\"+str2.getClass().hashCode()); System.out.println(\"String二维数组:\"+str3.getClass().hashCode()); System.out.println(\"int一维数组:\"+in.getClass().hashCode()); System.out.println(\"int二维数组:\"+in2.getClass().hashCode()); &#125;&#125; /*output String一维数组:460141958 String一维数组2:460141958 String二维数组:1163157884 int一维数组:1956725890 int二维数组:356573597 */ 1.获取Class对象方法123456789// 调用getClass方法MyObject x;Class clazz = x.getClass();//静态方法String path = \"cn.ileehan.demo.User\"Class clazz = Class.forName(path);// .classClass clazz = int.class;Class clazz1 = User.class; 2.Class类常用方法12newInstance(); // 创建实例，调用默认构造器getSuperclass(); // 返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class 1234567891011121314/*每种管理类型都是独一无二的Class对象，因此可以使用==来比较类对象if(e.getClass == Employee.class)....*/public class Demo4 &#123; public static void main(String[] args) &#123; Demo4 d = new Demo4(); if (d.getClass() == Demo4.class)&#123; System.out.println(true); &#125; &#125;&#125;//output:true 二、反射机制的常见作用UserInfo.java 1234567891011121314151617181920212223242526272829303132333435363738@ITable(\"t_talbe\")public class UserInfo &#123; @IField(name = \"id\",type = \"int\",length = 6) private int id; @IField(name = \"name\",type = \"varchar\",length = 10) private String name; @IField(name = \"age\",type = \"int\",length = 3) private int age; public UserInfo(int id) &#123; this.id = id; &#125; public UserInfo() &#123;&#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 1.动态加载类、动态获取类的信息（属性、方法、构造器）获取属性信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* * 获取成员变量并调用： * * 1.批量的 * 1).Field[] getFields():获取所有的”公有字段” * 2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有； * 2.获取单个的： * 1).public Field getField(String fieldName):获取某个”公有的”字段； * 2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的) * * 设置字段的值： * Field –&gt; public void set(Object obj,Object value): * 参数说明： * 1.obj:要设置的字段所在的对象； * 2.value:要为字段设置的值； * */ // 获取属性得到的是Field对象public class Dem &#123; public static void main(String[] args) &#123; try &#123; // 动态加载类 Class clazz = Class.forName(\"cn.ileehan.bean.UserInfo\"); // 获取属性信息 // Field field = clazz.getField(\"id\"); // 只能获取指定名称的公开属性信息 // Field[] field = clazz.getFields(); // 获取所有公开属性的信息 Field[] fields = clazz.getDeclaredFields(); // 获取全部属性 包括公开与非公开 for (Field temp : fields) &#123; System.out.println(\"属性：\"+temp); &#125; Field f = clazz.getDeclaredField(\"id\"); // 获取指定属性 包括公开与非公开 System.out.println(\"属性：\"+f); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*output属性：private int cn.ileehan.bean.UserInfo.id属性：private java.lang.String cn.ileehan.bean.UserInfo.name属性：private int cn.ileehan.bean.UserInfo.age属性：private int cn.ileehan.bean.UserInfo.id*/ 获取方法信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* * 获取成员方法并调用： * * 1.批量的： * public Method[] getMethods():获取所有”公有方法”；（包含了父类的方法也包含Object类） * public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的) * 2.获取单个的： * public Method getMethod(String name,Class&lt;?&gt;… parameterTypes): * 参数： * name : 方法名； * Class … : 形参的Class类型对象 * public Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes) * * 调用方法： * Method –&gt; public Object invoke(Object obj,Object… args): * 参数说明： * obj : 要调用方法的对象； * args:调用方式时所传递的实参； ): */ public class Dem &#123; public static void main(String[] args) &#123; try &#123; // 动态加载类 Class clazz = Class.forName(\"cn.ileehan.bean.UserInfo\"); /* *只能获取公开方法，包括该类 继承 或者实现的接口 Method[] method = clazz.getMethods(); // 返回所有方法 for (Method temp : method) &#123; System.out.println(\"方法：\"+temp); &#125; Method m = clazz.getMethod(\"setId\",int.class);// 获取指定方法 */ // all Method[] methods = clazz.getDeclaredMethods(); // 获取该类的所有方法 for (Method temp : methods) &#123; System.out.println(\"方法：\"+temp); &#125; Method m1 = clazz.getDeclaredMethod(\"getName\"); // 获取无参方法 System.out.println(\"方法：\"+m1); Method m2 = clazz.getDeclaredMethod(\"setId\",int.class); // 获取有参方法 System.out.println(\"方法：\"+m2); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*output方法：private java.lang.String cn.ileehan.bean.UserInfo.getName()方法：public int cn.ileehan.bean.UserInfo.getId()方法：public void cn.ileehan.bean.UserInfo.setName(java.lang.String)方法：public int cn.ileehan.bean.UserInfo.getAge()方法：public void cn.ileehan.bean.UserInfo.setAge(int)方法：public void cn.ileehan.bean.UserInfo.setId(int)方法：private java.lang.String cn.ileehan.bean.UserInfo.getName()方法：public void cn.ileehan.bean.UserInfo.setId(int)*/ 获取构造器信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员； * * 1.获取构造方法： * 1).批量的方法： * public Constructor[] getConstructors()：所有”公有的”构造方法 public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有) * 2).获取单个的方法，并调用： * public Constructor getConstructor(Class… parameterTypes):获取单个的”公有的”构造方法： * public Constructor getDeclaredConstructor(Class… parameterTypes):获取”某个构造方法”可以是私有的，或受保护、默认、公有； * * 调用构造方法： * Constructor–&gt;newInstance(Object… initargs) */ public class Dem &#123; public static void main(String[] args) &#123; try &#123; // 动态加载类 Class clazz = Class.forName(\"cn.ileehan.bean.UserInfo\"); // 获取构造器信息 /* 必须是公开的 Constructor[] constructor = clazz.getConstructors(); // 获取所有公开构造器 for (Constructor temp : constructor) &#123; System.out.println(\"构造器：\"+temp); &#125; Constructor c = clazz.getConstructor(int.class); // 获取指定构造器传参数类型的类 System.out.println(\"构造器：\"+c); */ // 获取所有的构造器 公开与非公开 Constructor[] constructors = clazz.getDeclaredConstructors();//获取所有构造器 for (Constructor temp : constructors) &#123; System.out.println(\"构造器：\"+temp); &#125; Constructor c = clazz.getDeclaredConstructor(int.class);//获取指定参数类型的构造器 System.out.println(\"构造器：\"+c); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*output构造器：public cn.ileehan.bean.UserInfo(int)构造器：public cn.ileehan.bean.UserInfo()构造器：public cn.ileehan.bean.UserInfo(int)*/ 2.动态使用（属性、方法、构造器）1234567891011121314151617181920212223242526272829303132public class Demo2 &#123; public static void main(String[] args) &#123; String path = \"cn.ileehan.bean.UserInfo\"; try &#123; Class&lt;UserInfo&gt; clazz = (Class&lt;UserInfo&gt;) Class.forName(path); // 通过反射API调用构造器，构造对象 UserInfo u = clazz.newInstance(); // 实际上调用了UserInfo的无参构造方法 System.out.println(u); //指定参数类型 Constructor&lt;UserInfo&gt; constructor = clazz.getDeclaredConstructor(int.class); UserInfo us = constructor.newInstance(12);//实例化的时候要按照构造器要求传值 System.out.println(us.getId()); // 通过反射API调用方法 UserInfo u2 = clazz.newInstance(); Method m = clazz.getDeclaredMethod(\"setName\", String.class); m.invoke(u2,\"李四\"); // 激活此方法 参数1-》哪里的方法 参数2-》按照方法的形参来 System.out.println(u2.getName()); // 通过反射API操作属性 UserInfo u3 = clazz.newInstance(); Field f = clazz.getDeclaredField(\"age\"); f.setAccessible(true); // 允许操作private 不用做安全检查了，可以直接访问 f.set(u3,123); // 通过反射直接写属性 System.out.println(u3.getAge()); // 通过反射直接读属性的值 System.out.println(f.get(u3)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 3.反射main方法123456789101112131415161718192021public class Demo2 &#123; public static void main(String[] args) &#123; String path = \"cn.ileehan.bean.UserInfo\"; try &#123; //获取UserInfo对象字节码 Class&lt;UserInfo&gt; clazz = (Class&lt;UserInfo&gt;) Class.forName(path); //获取main方法 Method methodMain = clazz.getMethod(\"main\",String[].class); //调用main方法 methodMain.invoke(null, (Object)new String[]&#123;\"a\",\"b\",\"c\"&#125;); /* 必须要加上(Object) 否则编译器会编译成 methodMain.invoke(null, \"a\",\"b\",\"c\"); */ &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 4.反射注解12345678910111213141516171819202122232425262728293031public class Demo &#123; public static void main(String[] args) &#123; try &#123; //获取UserInfo的class对象 Class cl = Class.forName(\"cn.ileehan.bean.UserInfo\"); // 获得类的所有注解 Annotation[] annotations = cl.getAnnotations(); for (Annotation a : annotations) &#123; System.out.println(a); &#125; // 获得类的指定注解 ITable table = (ITable) cl.getAnnotation(ITable.class); // 转成注解类型 System.out.println(table.value()); // 获得类的属性的注解 Field na = cl.getDeclaredField(\"name\"); // 通过反射获取指定属性 IField ie = na.getAnnotation(IField.class); System.out.println(ie.name()+\"---\"+ie.type()+\"---\"+ie.length()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*output@cn.ileehan.annotation.ITable(value=t_talbe)t_talbename---varchar---10*/ 5.通过反射越过泛型检查1234567891011121314151617181920212223242526// 想Sting泛型的集合，添加Integer类型的值public class Demo &#123; public static void main(String[] args) throws Exception&#123; ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add(\"aaa\"); strList.add(\"bbb\"); // strList.add(100); //获取ArrayList的Class对象，反向的调用add()方法，添加数据 Class listClass = strList.getClass(); //得到 strList 对象的字节码 对象 //获取add()方法 Method m = listClass.getMethod(\"add\", Object.class); //调用add()方法 m.invoke(strList, 100); //遍历集合 for(Object obj : strList)&#123; System.out.println(obj); &#125; &#125; &#125; /*outputaaabbb100*/ 参考文章：java反射（特别通俗易懂）","categories":[{"name":"Java","slug":"Java","permalink":"http://www.nullok.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.nullok.com/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://www.nullok.com/tags/笔记/"}]},{"title":"Java 注解 学习笔记","slug":"java注解学习笔记","date":"2019-07-19T14:54:22.000Z","updated":"2020-01-23T13:51:09.121Z","comments":true,"path":"2019/07/19/java注解学习笔记/","link":"","permalink":"http://www.nullok.com/2019/07/19/java注解学习笔记/","excerpt":"","text":"一、注解格式注解格式格式：@注释名/ @注释名(value) 例如： 1@SuppressWaring(\"all\") 二、内置注解1@Override // 用于修饰方法，表示重写 1@Deprecated // 可修饰方法 属性 类， 表示此方法弃用（不是不能用） 1@SuppressWarings // 抑制编译时的警告信息 参数 说明 deprecation 使用了过时的类或方法的警告 unchecked 执行了为检查的转换。eg:使用集合未指定泛型 fallthrough switch发生case穿透 path 资源或类路径不存在 serial 当前可序列化类上缺少serialVersionUID定义时的警告 finally 任何finally子句不能完成时的警告 all 关于以上的所有警告 eg: 12@SuppressWarings(\"fallthrough\")@SuppressWarings(value = &#123;\"unchecked\",\"deprecation\"&#125;) 三、自定义注解例子 123456789/*元注解public @interface 注解名｛注解体｝*/@Target(value = &#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface IField &#123; String name();&#125; 1.基本语法注解类型的声明部分： 注解在Java中，与类、接口、枚举类似，因此其声明语法基本一致，只是所使用的关键字有所不同@interface。在底层实现上，所有定义的注解都会自动继承java.lang.annotation.Annotation接口。 12public @interface IField &#123;&#125; 注解类型元素： 12345public @interface IField &#123; String name(); int age() default 12; int[] array();&#125; :warning:注意 该元素的类型只能是基本数据类型、Class、String、enum、注解类型以及上述类型的一位数组 若注解中只有一个元素，则将其命名为value（方便，在使用时可省略参数名） ()仅是特殊语法，不代表他是方法 如果没有默认值，使用时必须要给该类型元素赋值 定义注解时常用空字符串、0做默认值，可使用-1表示不存在 2.元注解元注解：专门修饰注解的注解 2.1 @Target用于描述注解的使用范围（注解用在什么位置上） 所修饰范围 取值ElementType package包 PACKAGE 类、接口、枚举、注解类型 TYPE 类成员(方法、构造方法、成员变量、枚举值) CONSTRUCTOR:描述构造器FIELD：用于描述成员变量METHOD:描述方法 方法参数和局部变量 LOCAL_VARIABLE:描述局部变量PARAMETER:描述参数 123456//@CherryAnnotation被限定只能使用在类、接口或方法上面@Target(value = &#123;ElementType.TYPE,ElementType.METHOD&#125;)public @interface CherryAnnotation &#123; String name(); &#125; 2.2 @Retention用于描述注解的生命周期 取值RetentionPolicy 作用 SOURCE 在源文件中有效（给人看的） CLASS 在class文件中有效（JVM忽略它） RUNTIME 在运行时有效，此时可以被反射机制读取 1234@Retention(RetentionPolicy.RUNTIME) // 运行时有效public @interface IField &#123; String name();&#125; 默认情况下，自定义注解使用的是RetentionPolicy.CLASS 四、反射机制读取注解信息Demo.java 12345678910111213141516171819202122232425262728293031public class Demo &#123; public static void main(String[] args) &#123; try &#123; //获取UserInfo的class对象 Class cl = Class.forName(\"cn.ileehan.bean.UserInfo\"); // 获得类的所有注解 Annotation[] annotations = cl.getAnnotations(); for (Annotation a : annotations) &#123; System.out.println(a); &#125; // 获得类的指定注解 ITable table = (ITable) cl.getAnnotation(ITable.class); System.out.println(table.value()); // 获得类的属性的注解 Field na = cl.getDeclaredField(\"name\"); // 通过反射获取指定属性 IField ie = na.getAnnotation(IField.class); System.out.println(ie.name()+\"---\"+ie.type()+\"---\"+ie.length()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*output@cn.ileehan.annotation.ITable(value=t_talbe)t_talbename---varchar---10*/ ITable.java 12345@Target(value = &#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ITable &#123; String value();&#125; IField.java 1234567@Target(value = &#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface IField &#123; String name(); String type(); int length();&#125; UserInfo.java 12345678910@ITable(\"t_talbe\")public class UserInfo &#123; @IField(name = \"id\",type = \"int\",length = 6) private int id; @IField(name = \"name\",type = \"varchar\",length = 10) private String name; @IField(name = \"age\",type = \"int\",length = 3) private int age;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.nullok.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.nullok.com/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://www.nullok.com/tags/笔记/"}]}]}