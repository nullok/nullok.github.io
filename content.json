{"pages":[{"title":"关于我","text":"","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"IDEA导入mysql驱动，运行时找不到驱动包解决方案","text":"状况： 驱动导入了。 编译成功，运行报错： 解决办法 在WEB-INF目录下创建lib文件夹，将驱动包放入文件夹，并将lib文件设置为resources 再次添加驱动包就可以了","link":"/2019/07/23/IDEA导入mysql驱动，运行时找不到驱动包解决方案/"},{"title":"Struts2.5.x遇到的坑","text":"通配符访问方法，报错404错误找不到页面报错截图 报错内容：There is no Action mapped for namespace [/] and action name [Emp_edit] associated with context path [/demo]. 错误原因：Struts2.5 为了提升安全性，默认开启了Strict Method Invocation（strict-method-invocation） 在SMI开启的情况下，通配符不会匹配所有的方法名，而是会匹配在default-struts.xml文件中global-allowed-methods属性所允许的方法名或者是匹配通过 &lt;allowed-method/&gt;标签来定义的方法名。 解决方法： ​ 方法一 在struts.xml中的package下添加regex:.*，匹配所有。 ​ 方法二 将package标签的属性strict-method-invocation设置为false。 默认全局允许匹配的方法名称： 动态匹配问题官方解释","link":"/2019/07/29/Struts2-5-x遇到的坑/"},{"title":"MyEclipse2017破解方法","text":"方法安装包链接: https://pan.baidu.com/s/139Yc0FYVeKckEfgPMROhkQ 提取码: ilee 破解文件链接: https://pan.baidu.com/s/1eEn8nKAa07nnNnv_U-hnJw 提取码: ilee 首先配置好Java环境。 安装MyEclipse。 在安装最后一步，千万别点那个打开MyEclipse。 关闭安装界面后，把破解文件中的path里的所有文件拷贝进你的安装目录里的plugins，这里提醒你替换，选择替换。 替换完成后，再打开破解文件里myeclipse_keygen文件夹里的crack.bat，如果你发现点开闪退，这是你Java环境没有配置好的原因，去配置好你的Java环境，再运行crack.bat，出来一个界面。上面的空是你的用户名，这里自己起个名就ok，后面那个里面有很多版本，自己选择一个版本。 输好用户名，选择好版本，点一下systemid，再点一下systemid，然后点一下active，然后窗口下方会出现一堆东西例如这些： 12345678LICENSEE JerryLICENSE_KEY WLR8ZO-855555-7653625140119936ACTIVATION_CODE 11dFE23feaa1DBFE147730WLR8ZO-855555-7653625140119936210817ACTIVATION_KEY b5f7219363534b3fe8c02272c4cae4bff6621a5ceab73c4212c7e9e79fcf9ea5a5eedc9552a9901ef542ea90b474a6de64fe91b24b1e899982ff0a0152bb9ebae97efa69edd53ca90ccd85135f17a16571c297be4489108071870bf92d255f8dd95e01806d03727767b09e468dae9ac6c7a324126c026e483d0f20d2a231073d 看到这些，保留这个窗口，打开MyEclipse，打开后，选择active now，输入你的用户名和那个license key，然后，继续激活，选择我已经有激活文件（这里应该是英文，大家自己理解意思哈），输入activation_key下面那一大串的东西，然后激活就OK。 方法来源52破解","link":"/2019/07/20/MyEclipse2017破解方法/"},{"title":"Java 反射(Reflection) 学习笔记","text":"一、反射概述JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 (网图) 类加载过程： 二、Class类（包含完整的类的结构信息）Class对象由来：将class文件读入内存，并为之创建一个Class对象 Class 没有public 构造器。Class 对象是在加载类时由Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。 每个类（型）都有一个Class对象 Java基本类型和void都对应一个Class对象 每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。 1234567891011121314151617181920212223//每个数组属于被映射为 `Class` 对象的一个类，所有具有相同元素类型和维数的数组都共享该 `Class` 对象public class Demo3 { public static void main(String[] args) { String[] str = new String[3]; String[] str2 = new String[30]; String[][] str3 = new String[3][]; int[] in = new int[3]; int[][] in2 = new int[3][]; System.out.println(\"String一维数组:\"+str.getClass().hashCode()); System.out.println(\"String一维数组（30）:\"+str2.getClass().hashCode()); System.out.println(\"String二维数组:\"+str3.getClass().hashCode()); System.out.println(\"int一维数组:\"+in.getClass().hashCode()); System.out.println(\"int二维数组:\"+in2.getClass().hashCode()); }} /*output String一维数组:460141958 String一维数组2:460141958 String二维数组:1163157884 int一维数组:1956725890 int二维数组:356573597 */ 1.获取Class对象方法123456789// 调用getClass方法MyObject x;Class clazz = x.getClass();//静态方法String path = \"cn.ileehan.demo.User\"Class clazz = Class.forName(path);// .classClass clazz = int.class;Class clazz1 = User.class; 2.Class类常用方法12newInstance(); // 创建实例，调用默认构造器getSuperclass(); // 返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class 1234567891011121314/*每种管理类型都是独一无二的Class对象，因此可以使用==来比较类对象if(e.getClass == Employee.class)....*/public class Demo4 { public static void main(String[] args) { Demo4 d = new Demo4(); if (d.getClass() == Demo4.class){ System.out.println(true); } }}//output:true 二、反射机制的常见作用UserInfo.java 1234567891011121314151617181920212223242526272829303132333435363738@ITable(\"t_talbe\")public class UserInfo { @IField(name = \"id\",type = \"int\",length = 6) private int id; @IField(name = \"name\",type = \"varchar\",length = 10) private String name; @IField(name = \"age\",type = \"int\",length = 3) private int age; public UserInfo(int id) { this.id = id; } public UserInfo() {} public String getName() { return name; } public void setName(String name) { this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 1.动态加载类、动态获取类的信息（属性、方法、构造器）获取属性信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* * 获取成员变量并调用： * * 1.批量的 * 1).Field[] getFields():获取所有的”公有字段” * 2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有； * 2.获取单个的： * 1).public Field getField(String fieldName):获取某个”公有的”字段； * 2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的) * * 设置字段的值： * Field –&gt; public void set(Object obj,Object value): * 参数说明： * 1.obj:要设置的字段所在的对象； * 2.value:要为字段设置的值； * */ // 获取属性得到的是Field对象public class Dem { public static void main(String[] args) { try { // 动态加载类 Class clazz = Class.forName(\"cn.ileehan.bean.UserInfo\"); // 获取属性信息 // Field field = clazz.getField(\"id\"); // 只能获取指定名称的公开属性信息 // Field[] field = clazz.getFields(); // 获取所有公开属性的信息 Field[] fields = clazz.getDeclaredFields(); // 获取全部属性 包括公开与非公开 for (Field temp : fields) { System.out.println(\"属性：\"+temp); } Field f = clazz.getDeclaredField(\"id\"); // 获取指定属性 包括公开与非公开 System.out.println(\"属性：\"+f); } catch (Exception e) { e.printStackTrace(); } }}/*output属性：private int cn.ileehan.bean.UserInfo.id属性：private java.lang.String cn.ileehan.bean.UserInfo.name属性：private int cn.ileehan.bean.UserInfo.age属性：private int cn.ileehan.bean.UserInfo.id*/ 获取方法信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* * 获取成员方法并调用： * * 1.批量的： * public Method[] getMethods():获取所有”公有方法”；（包含了父类的方法也包含Object类） * public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的) * 2.获取单个的： * public Method getMethod(String name,Class&lt;?&gt;… parameterTypes): * 参数： * name : 方法名； * Class … : 形参的Class类型对象 * public Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes) * * 调用方法： * Method –&gt; public Object invoke(Object obj,Object… args): * 参数说明： * obj : 要调用方法的对象； * args:调用方式时所传递的实参； ): */ public class Dem { public static void main(String[] args) { try { // 动态加载类 Class clazz = Class.forName(\"cn.ileehan.bean.UserInfo\"); /* *只能获取公开方法，包括该类 继承 或者实现的接口 Method[] method = clazz.getMethods(); // 返回所有方法 for (Method temp : method) { System.out.println(\"方法：\"+temp); } Method m = clazz.getMethod(\"setId\",int.class);// 获取指定方法 */ // all Method[] methods = clazz.getDeclaredMethods(); // 获取该类的所有方法 for (Method temp : methods) { System.out.println(\"方法：\"+temp); } Method m1 = clazz.getDeclaredMethod(\"getName\"); // 获取无参方法 System.out.println(\"方法：\"+m1); Method m2 = clazz.getDeclaredMethod(\"setId\",int.class); // 获取有参方法 System.out.println(\"方法：\"+m2); } catch (Exception e) { e.printStackTrace(); } }}/*output方法：private java.lang.String cn.ileehan.bean.UserInfo.getName()方法：public int cn.ileehan.bean.UserInfo.getId()方法：public void cn.ileehan.bean.UserInfo.setName(java.lang.String)方法：public int cn.ileehan.bean.UserInfo.getAge()方法：public void cn.ileehan.bean.UserInfo.setAge(int)方法：public void cn.ileehan.bean.UserInfo.setId(int)方法：private java.lang.String cn.ileehan.bean.UserInfo.getName()方法：public void cn.ileehan.bean.UserInfo.setId(int)*/ 获取构造器信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员； * * 1.获取构造方法： * 1).批量的方法： * public Constructor[] getConstructors()：所有”公有的”构造方法 public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有) * 2).获取单个的方法，并调用： * public Constructor getConstructor(Class… parameterTypes):获取单个的”公有的”构造方法： * public Constructor getDeclaredConstructor(Class… parameterTypes):获取”某个构造方法”可以是私有的，或受保护、默认、公有； * * 调用构造方法： * Constructor–&gt;newInstance(Object… initargs) */ public class Dem { public static void main(String[] args) { try { // 动态加载类 Class clazz = Class.forName(\"cn.ileehan.bean.UserInfo\"); // 获取构造器信息 /* 必须是公开的 Constructor[] constructor = clazz.getConstructors(); // 获取所有公开构造器 for (Constructor temp : constructor) { System.out.println(\"构造器：\"+temp); } Constructor c = clazz.getConstructor(int.class); // 获取指定构造器传参数类型的类 System.out.println(\"构造器：\"+c); */ // 获取所有的构造器 公开与非公开 Constructor[] constructors = clazz.getDeclaredConstructors();//获取所有构造器 for (Constructor temp : constructors) { System.out.println(\"构造器：\"+temp); } Constructor c = clazz.getDeclaredConstructor(int.class);//获取指定参数类型的构造器 System.out.println(\"构造器：\"+c); } catch (Exception e) { e.printStackTrace(); } }}/*output构造器：public cn.ileehan.bean.UserInfo(int)构造器：public cn.ileehan.bean.UserInfo()构造器：public cn.ileehan.bean.UserInfo(int)*/ 2.动态使用（属性、方法、构造器）1234567891011121314151617181920212223242526272829303132public class Demo2 { public static void main(String[] args) { String path = \"cn.ileehan.bean.UserInfo\"; try { Class&lt;UserInfo&gt; clazz = (Class&lt;UserInfo&gt;) Class.forName(path); // 通过反射API调用构造器，构造对象 UserInfo u = clazz.newInstance(); // 实际上调用了UserInfo的无参构造方法 System.out.println(u); //指定参数类型 Constructor&lt;UserInfo&gt; constructor = clazz.getDeclaredConstructor(int.class); UserInfo us = constructor.newInstance(12);//实例化的时候要按照构造器要求传值 System.out.println(us.getId()); // 通过反射API调用方法 UserInfo u2 = clazz.newInstance(); Method m = clazz.getDeclaredMethod(\"setName\", String.class); m.invoke(u2,\"李四\"); // 激活此方法 参数1-》哪里的方法 参数2-》按照方法的形参来 System.out.println(u2.getName()); // 通过反射API操作属性 UserInfo u3 = clazz.newInstance(); Field f = clazz.getDeclaredField(\"age\"); f.setAccessible(true); // 允许操作private 不用做安全检查了，可以直接访问 f.set(u3,123); // 通过反射直接写属性 System.out.println(u3.getAge()); // 通过反射直接读属性的值 System.out.println(f.get(u3)); } catch (Exception e) { e.printStackTrace(); } }} 3.反射main方法123456789101112131415161718192021public class Demo2 { public static void main(String[] args) { String path = \"cn.ileehan.bean.UserInfo\"; try { //获取UserInfo对象字节码 Class&lt;UserInfo&gt; clazz = (Class&lt;UserInfo&gt;) Class.forName(path); //获取main方法 Method methodMain = clazz.getMethod(\"main\",String[].class); //调用main方法 methodMain.invoke(null, (Object)new String[]{\"a\",\"b\",\"c\"}); /* 必须要加上(Object) 否则编译器会编译成 methodMain.invoke(null, \"a\",\"b\",\"c\"); */ } catch (Exception e) { e.printStackTrace(); } }} 4.反射注解12345678910111213141516171819202122232425262728293031public class Demo { public static void main(String[] args) { try { //获取UserInfo的class对象 Class cl = Class.forName(\"cn.ileehan.bean.UserInfo\"); // 获得类的所有注解 Annotation[] annotations = cl.getAnnotations(); for (Annotation a : annotations) { System.out.println(a); } // 获得类的指定注解 ITable table = (ITable) cl.getAnnotation(ITable.class); // 转成注解类型 System.out.println(table.value()); // 获得类的属性的注解 Field na = cl.getDeclaredField(\"name\"); // 通过反射获取指定属性 IField ie = na.getAnnotation(IField.class); System.out.println(ie.name()+\"---\"+ie.type()+\"---\"+ie.length()); } catch (Exception e) { e.printStackTrace(); } }}/*output@cn.ileehan.annotation.ITable(value=t_talbe)t_talbename---varchar---10*/ 5.通过反射越过泛型检查1234567891011121314151617181920212223242526// 想Sting泛型的集合，添加Integer类型的值public class Demo { public static void main(String[] args) throws Exception{ ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add(\"aaa\"); strList.add(\"bbb\"); // strList.add(100); //获取ArrayList的Class对象，反向的调用add()方法，添加数据 Class listClass = strList.getClass(); //得到 strList 对象的字节码 对象 //获取add()方法 Method m = listClass.getMethod(\"add\", Object.class); //调用add()方法 m.invoke(strList, 100); //遍历集合 for(Object obj : strList){ System.out.println(obj); } } } /*outputaaabbb100*/ 参考文章：java反射（特别通俗易懂）","link":"/2019/07/20/java反射学习笔记/"},{"title":"Java 注解 学习笔记","text":"一、注解格式注解格式格式：@注释名/ @注释名(value) 例如： 1@SuppressWaring(\"all\") 二、内置注解1@Override // 用于修饰方法，表示重写 1@Deprecated // 可修饰方法 属性 类， 表示此方法弃用（不是不能用） 1@SuppressWarings // 抑制编译时的警告信息 参数 说明 deprecation 使用了过时的类或方法的警告 unchecked 执行了为检查的转换。eg:使用集合未指定泛型 fallthrough switch发生case穿透 path 资源或类路径不存在 serial 当前可序列化类上缺少serialVersionUID定义时的警告 finally 任何finally子句不能完成时的警告 all 关于以上的所有警告 eg: 12@SuppressWarings(\"fallthrough\")@SuppressWarings(value = {\"unchecked\",\"deprecation\"}) 三、自定义注解例子 123456789/*元注解public @interface 注解名｛注解体｝*/@Target(value = {ElementType.FIELD})@Retention(RetentionPolicy.RUNTIME)public @interface IField { String name();} 1.基本语法注解类型的声明部分： 注解在Java中，与类、接口、枚举类似，因此其声明语法基本一致，只是所使用的关键字有所不同@interface。在底层实现上，所有定义的注解都会自动继承java.lang.annotation.Annotation接口。 12public @interface IField {} 注解类型元素： 12345public @interface IField { String name(); int age() default 12; int[] array();} :warning:注意 该元素的类型只能是基本数据类型、Class、String、enum、注解类型以及上述类型的一位数组 若注解中只有一个元素，则将其命名为value（方便，在使用时可省略参数名） ()仅是特殊语法，不代表他是方法 如果没有默认值，使用时必须要给该类型元素赋值 定义注解时常用空字符串、0做默认值，可使用-1表示不存在 2.元注解元注解：专门修饰注解的注解 2.1 @Target用于描述注解的使用范围（注解用在什么位置上） 所修饰范围 取值ElementType package包 PACKAGE 类、接口、枚举、注解类型 TYPE 类成员(方法、构造方法、成员变量、枚举值) CONSTRUCTOR:描述构造器FIELD：用于描述成员变量METHOD:描述方法 方法参数和局部变量 LOCAL_VARIABLE:描述局部变量PARAMETER:描述参数 123456//@CherryAnnotation被限定只能使用在类、接口或方法上面@Target(value = {ElementType.TYPE,ElementType.METHOD})public @interface CherryAnnotation { String name(); } 2.2 @Retention用于描述注解的生命周期 取值RetentionPolicy 作用 SOURCE 在源文件中有效（给人看的） CLASS 在class文件中有效（JVM忽略它） RUNTIME 在运行时有效，此时可以被反射机制读取 1234@Retention(RetentionPolicy.RUNTIME) // 运行时有效public @interface IField { String name();} 默认情况下，自定义注解使用的是RetentionPolicy.CLASS 四、反射机制读取注解信息Demo.java 12345678910111213141516171819202122232425262728293031public class Demo { public static void main(String[] args) { try { //获取UserInfo的class对象 Class cl = Class.forName(\"cn.ileehan.bean.UserInfo\"); // 获得类的所有注解 Annotation[] annotations = cl.getAnnotations(); for (Annotation a : annotations) { System.out.println(a); } // 获得类的指定注解 ITable table = (ITable) cl.getAnnotation(ITable.class); System.out.println(table.value()); // 获得类的属性的注解 Field na = cl.getDeclaredField(\"name\"); // 通过反射获取指定属性 IField ie = na.getAnnotation(IField.class); System.out.println(ie.name()+\"---\"+ie.type()+\"---\"+ie.length()); } catch (Exception e) { e.printStackTrace(); } }}/*output@cn.ileehan.annotation.ITable(value=t_talbe)t_talbename---varchar---10*/ ITable.java 12345@Target(value = {ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)public @interface ITable { String value();} IField.java 1234567@Target(value = {ElementType.FIELD})@Retention(RetentionPolicy.RUNTIME)public @interface IField { String name(); String type(); int length();} UserInfo.java 12345678910@ITable(\"t_talbe\")public class UserInfo { @IField(name = \"id\",type = \"int\",length = 6) private int id; @IField(name = \"name\",type = \"varchar\",length = 10) private String name; @IField(name = \"age\",type = \"int\",length = 3) private int age;}","link":"/2019/07/19/java注解学习笔记/"},{"title":"springboot+mybatis配置中遇到的问题","text":"遇到的问题配置数据源123456789101112131415161718192021222324@Configuration@MapperScan(\"cn.ileehan.community.dao\")public class DataSourceConfiguration { @Value(\"${c3p0.driver}\") private String jdbcDriver; @Value(\"${c3p0.url}\") private String jdbcUrl; @Value(\"${c3p0.name}\") private String jdbcUsername; @Value(\"${c3p0.password}\") private String jdbcPassword; @Bean(name = \"dataSource\") public ComboPooledDataSource createDataSource() throws PropertyVetoException { ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(jdbcDriver); dataSource.setJdbcUrl(jdbcUrl); dataSource.setUser(jdbcUsername); dataSource.setPassword(jdbcPassword); // 关闭连接之后不自动commit dataSource.setAutoCommitOnClose(false); return dataSource; }} 配置SqlSessionFactoryBean123456789101112131415161718192021222324252627282930313233@Configurationpublic class SessionFactoryConfiguration { @Value(\"${mapper.xml.config.path}\") private String mapperXMLConfigPath; @Value(\"${mapper.package.path}\") private String mapperPackagePath; @Value(\"${mapper.global.config}\") private String globalConfig; @Autowired private DataSource dataSource; @Bean public SqlSessionFactoryBean createSqlSessionFactory() throws IOException { SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); // resource查找器可以查找类路径下或文件路径下的资源 PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); // mapperXML文件路径 String packageMapperXMLConfigPath = PathMatchingResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + mapperXMLConfigPath; // mybatis-config.xml路径 String globalConfigPath = PathMatchingResourcePatternResolver.CLASSPATH_URL_PREFIX + globalConfig; // 设置 mapper 对应的 XML 文件的路径 sqlSessionFactoryBean.setMapperLocations(resolver.getResources(packageMapperXMLConfigPath)); // 设置数据源 sqlSessionFactoryBean.setDataSource(dataSource); // 设置 mapper 接口所在的包 sqlSessionFactoryBean.setTypeAliasesPackage(mapperPackagePath); // 设置mybatis-config.xml，否则xml中全局配置将失效 sqlSessionFactoryBean.setConfigLocation(resolver.getResource(globalConfigPath)); return sqlSessionFactoryBean; }} 注意：在使用配置类配置SqlSessionFactoryBean时，要记得设置setConfigLocation #","link":"/2019/10/05/springboot-mybatis配置中遇到的问题/"}],"tags":[{"name":"-Servlet","slug":"Servlet","link":"/tags/Servlet/"},{"name":"-Struts2 -Java","slug":"Struts2-Java","link":"/tags/Struts2-Java/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"工具","slug":"工具","link":"/tags/工具/"},{"name":"笔记","slug":"笔记","link":"/tags/笔记/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"Mybatis","slug":"Mybatis","link":"/tags/Mybatis/"}],"categories":[{"name":"Servlet","slug":"Servlet","link":"/categories/Servlet/"},{"name":"Struts2","slug":"Struts2","link":"/categories/Struts2/"},{"name":"工具","slug":"工具","link":"/categories/工具/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/categories/SpringBoot/"}]}