<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 注解 学习笔记]]></title>
    <url>%2F2019%2F07%2F19%2Fjava%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、注解格式注解格式格式：@注释名/ @注释名(value) 例如： 1@SuppressWaring("all") 二、内置注解1@Override // 用于修饰方法，表示重写 1@Deprecated // 可修饰方法 属性 类， 表示此方法弃用（不是不能用） 1@SuppressWarings // 抑制编译时的警告信息 参数 说明 deprecation 使用了过时的类或方法的警告 unchecked 执行了为检查的转换。eg:使用集合未指定泛型 fallthrough switch发生case穿透 path 资源或类路径不存在 serial 当前可序列化类上缺少serialVersionUID定义时的警告 finally 任何finally子句不能完成时的警告 all 关于以上的所有警告 eg: 12@SuppressWarings("fallthrough")@SuppressWarings(value = &#123;"unchecked","deprecation"&#125;) 三、自定义注解例子 123456789/*元注解public @interface 注解名｛注解体｝*/@Target(value = &#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface IField &#123; String name();&#125; 1.基本语法注解类型的声明部分： 注解在Java中，与类、接口、枚举类似，因此其声明语法基本一致，只是所使用的关键字有所不同@interface。在底层实现上，所有定义的注解都会自动继承java.lang.annotation.Annotation接口。 12public @interface IField &#123;&#125; 注解类型元素： 12345public @interface IField &#123; String name(); int age() default 12; int[] array();&#125; :warning:注意 该元素的类型只能是基本数据类型、Class、String、enum、注解类型以及上述类型的一位数组 若注解中只有一个元素，则将其命名为value（方便，在使用时可省略参数名） ()仅是特殊语法，不代表他是方法 如果没有默认值，使用时必须要给该类型元素赋值 定义注解时常用空字符串、0做默认值，可使用-1表示不存在 2.元注解元注解：专门修饰注解的注解 2.1 @Target用于描述注解的使用范围（注解用在什么位置上） 所修饰范围 取值ElementType package包 PACKAGE 类、接口、枚举、注解类型 TYPE 类成员(方法、构造方法、成员变量、枚举值) CONSTRUCTOR:描述构造器FIELD：用于描述成员变量METHOD:描述方法 方法参数和局部变量 LOCAL_VARIABLE:描述局部变量PARAMETER:描述参数 123456//@CherryAnnotation被限定只能使用在类、接口或方法上面@Target(value = &#123;ElementType.TYPE,ElementType.METHOD&#125;)public @interface CherryAnnotation &#123; String name(); &#125; 2.2 @Retention用于描述注解的生命周期 取值RetentionPolicy 作用 SOURCE 在源文件中有效（给人看的） CLASS 在class文件中有效（JVM忽略它） RUNTIME 在运行时有效，此时可以被反射机制读取 1234@Retention(RetentionPolicy.RUNTIME) // 运行时有效public @interface IField &#123; String name();&#125; 默认情况下，自定义注解使用的是RetentionPolicy.CLASS 四、反射机制读取注解信息Demo.java 12345678910111213141516171819202122232425262728293031public class Demo &#123; public static void main(String[] args) &#123; try &#123; //获取UserInfo的class对象 Class cl = Class.forName("cn.ileehan.bean.UserInfo"); // 获得类的所有注解 Annotation[] annotations = cl.getAnnotations(); for (Annotation a : annotations) &#123; System.out.println(a); &#125; // 获得类的指定注解 ITable table = (ITable) cl.getAnnotation(ITable.class); System.out.println(table.value()); // 获得类的属性的注解 Field na = cl.getDeclaredField("name"); // 通过反射获取指定属性 IField ie = na.getAnnotation(IField.class); System.out.println(ie.name()+"---"+ie.type()+"---"+ie.length()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*output@cn.ileehan.annotation.ITable(value=t_talbe)t_talbename---varchar---10*/ ITable.java 12345@Target(value = &#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ITable &#123; String value();&#125; IField.java 1234567@Target(value = &#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface IField &#123; String name(); String type(); int length();&#125; UserInfo.java 12345678910@ITable("t_talbe")public class UserInfo &#123; @IField(name = "id",type = "int",length = 6) private int id; @IField(name = "name",type = "varchar",length = 10) private String name; @IField(name = "age",type = "int",length = 3) private int age;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
