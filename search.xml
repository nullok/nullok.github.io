<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决git无法忽略target办法]]></title>
    <url>%2F2020%2F01%2F28%2F%E8%A7%A3%E5%86%B3git%E6%97%A0%E6%B3%95%E5%BF%BD%E7%95%A5target%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0x001 添加.gitignore配置忽略文件规则11.创建文件.gitignore 1232.添加内容/target/.idea 0x002 git 配置.gitignore1git config core.excludesfile .gitignore 0x003 解决.gitignore不生效.gitignore只能忽略原来没有被跟踪的文件，因此跟踪过的文件是无法被忽略的。因此在网页上可以看到target等目录的存在。解决方法就是先把本地缓存删除（改变成未track状态），然后再提交: 123git rm -r --cached .git add .git commit -m &apos;xxx&apos; 0x004 推送1git push]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro禁止多点登录或重复登录]]></title>
    <url>%2F2020%2F01%2F26%2Fshiro%E7%A6%81%E6%AD%A2%E5%A4%9A%E7%82%B9%E7%99%BB%E5%BD%95%E6%88%96%E9%87%8D%E5%A4%8D%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[目的：每个用户只允许一个session可用，在redis中也只能有一条session记录 为演示直接在Controller层进行控制（我也不是很清楚应该在哪里进行控制，哈哈哈） 思路：shiro认证通过之后向session中保存当前登录的账号（唯一识别），获取redis 中存的所有session，依据上次登录向session保存的信息找到上一次存的session，先删除redis中的session，在设置session失效。 缺点：用户量大的时候效率太低。 12345678910111213141516171819202122232425262728293031 @PostMapping("/login")public Object login(String phone,String password) &#123; System.out.println(password+phone); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken upToken = new UsernamePasswordToken(phone, password); try &#123; subject.login(upToken); // shiro认证通过之后 才进行session的替换 if (subject.isAuthenticated()) &#123; // 获取所有的session Collection&lt;Session&gt; activeSessions = sessionDAO.getActiveSessions(); if(activeSessions.size() &gt; 0) &#123; activeSessions.forEach(session -&gt; &#123; // 找到当前phone的session（上一次存的session） if (phone.equals(session.getAttribute("phoneKey")) &#123; // 先在redis 中删除 sessionRedisTemplate.delete(AppConstants.SHIRO_SESSION_REDIS_PREFIX + session.getId()); // 在设置session失效，否则先失效就获取不到id了 session.setTimeout(0); &#125; &#125;); &#125; &#125; /*向session中保存当前登录的手机号，以便检测是否登录过*/ subject.getSession().setAttribute("phoneKey", phone); &#125; catch (UnknownAccountException | IncorrectCredentialsException e) &#123; return ResultEntity.error(ResultStatus.USERNAME_OR_PASSWORD_ERROR); &#125; return ResultEntity.ok();&#125;]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro + Redis自定义session会话管理]]></title>
    <url>%2F2020%2F01%2F23%2FShiro-Redis%E8%87%AA%E5%AE%9A%E4%B9%89session%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[此图非常重要！！！镇楼 0x001 重写SessionManagershiro提供了三种默认实现： DefaultSessionManager： 用于java se 环境 ServletContainerSessionManager：默认使用的实现，Servlet容器管理 DefaultWebSessionManager：自己维护 重写SessionManager需要继承DefaultWebSessionManager类 目的：自定义从header中的Authorization获取token 1234567891011121314151617public class CustomSessionManager extends DefaultWebSessionManager &#123; @Override protected Serializable getSessionId(ServletRequest request, ServletResponse response) &#123; String id = WebUtils.toHttp(request).getHeader("Authorization"); if (StringUtils.isEmpty(id)) &#123; // 获取sessionId，id可以自定义 return super.getSessionId(request, response); &#125; else &#123; //返回sessionId；固定套路 request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, "header"); request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id); request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE); return id; &#125; &#125;&#125; 0x002 重写SessionDao重写SessionDao 需要实现SessionDAO接口 继承以下子类也可以： 继承AbstractSessionDAO，其实现了基础的实现 ps: ​ 注意！！！！！！！ ​ 一定要自己把session转换成二进制在用redistemplate存到redis 中，直接用redistemplate的对象序列化器，会出错误！！！！！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091@Componentpublic class SelfSessionDao extends AbstractSessionDAO &#123; @Resource(name = "SessionRedisTemplate") private RedisTemplate&lt;Object, byte[]&gt; redisTemplate; // 创建session 存到redis @Override protected Serializable doCreate(Session session) &#123; Serializable sessionId = generateSessionId(session); assignSessionId(session, sessionId); redisTemplate.boundValueOps(AppConstants.SHIRO_SESSION_REDIS_PREFIX + sessionId) .set(sessionToByte(session), AppConstants.TOKEN_EXPIRES_HOUR, TimeUnit.HOURS); return sessionId; &#125; @Override protected Session doReadSession(Serializable sessionId) &#123; byte[] bytes = redisTemplate.boundValueOps(AppConstants.SHIRO_SESSION_REDIS_PREFIX + sessionId).get(); return byteToSession(bytes); &#125; /** * 更新 * @param session * @throws UnknownSessionException */ @Override public void update(Session session) throws UnknownSessionException &#123; if (session == null || session.getId() == null) &#123; throw new UnknownSessionException("session 或者 sessionId为空"); &#125; redisTemplate.boundValueOps(AppConstants.SHIRO_SESSION_REDIS_PREFIX + session.getId()) .set(sessionToByte(session), AppConstants.TOKEN_EXPIRES_HOUR, TimeUnit.HOURS); &#125; /** * 删除session * @param session */ @Override public void delete(Session session) &#123; redisTemplate.delete(AppConstants.SHIRO_SESSION_REDIS_PREFIX + session.getId()); &#125; @Override public Collection&lt;Session&gt; getActiveSessions() &#123; Set&lt;Object&gt; keys = redisTemplate.keys(AppConstants.SHIRO_SESSION_REDIS_PREFIX + "*"); if (keys != null) &#123; return keys.stream().map(key -&gt; &#123; byte[] bytes = redisTemplate.boundValueOps(key).get(); return byteToSession(bytes); &#125;).collect(Collectors.toList()); &#125; else &#123; return null; &#125; &#125; // 把session对象转化为byte保存到redis中 public byte[] sessionToByte(Session session)&#123; ByteArrayOutputStream bo = new ByteArrayOutputStream(); byte[] bytes = null; try &#123; ObjectOutputStream oo = new ObjectOutputStream(bo); oo.writeObject(session); bytes = bo.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return bytes; &#125; // 把byte还原为session public Session byteToSession(byte[] bytes)&#123; ByteArrayInputStream bi = new ByteArrayInputStream(bytes); ObjectInputStream in; SimpleSession session = null; try &#123; in = new ObjectInputStream(bi); session = (SimpleSession) in.readObject(); &#125; catch (ClassNotFoundException | IOException e) &#123; e.printStackTrace(); &#125; return session; &#125;&#125; 0x003自定义id生成器12345678public class CustomSessionIdGenerator implements SessionIdGenerator &#123; @Override public Serializable generateId(Session session) &#123; //... 生成id逻辑 return id; &#125;&#125; 0x004 配置类12345678910111213141516171819202122@Bean public SecurityManager getSecurityManager(CustomRealm realm,DefaultWebSessionManager defaultWebSessionManager) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(realm); //将自定义的会话管理器注册到安全管理器中 securityManager.setSessionManager(defaultWebSessionManager); //将自定义的redis缓存管理器注册到安全管理器中 securityManager.setCacheManager(selfCacheManager()); return securityManager; &#125;//会话管理器@Bean public DefaultWebSessionManager sessionManager(SelfSessionDao selfSessionDao) &#123; CustomSessionManager sessionManager = new CustomSessionManager(); // 自定义sessionDAO sessionManager.setSessionDAO(selfSessionDao); // 自定义id生成器 selfSessionDao.setSessionIdGenerator(new CustomSessionIdGenerator()); return sessionManager; &#125;]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu中docker开启远程模式]]></title>
    <url>%2F2020%2F01%2F22%2FUbuntu%E4%B8%ADdocker%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[0x011vim /lib/systemd/system/docker.service 0x02找到ExecStart,并添加-H tcp://0.0.0.0:2375 12原：ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock 123增加-H tcp://0.0.0.0:2375：ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H fd:// --containerd=/run/containerd/containerd.sock 0x0312systemctl daemon-reload // 加载docker守护线程systemctl restart docker // 重启docker 0x04测试是否成功 1docker -H 127.0.0.1 info 12345678910111213显示信息Client: Debug Mode: falseServer: Containers: 5 Running: 1 Paused: 0 Stopped: 4 Images: 6 Server Version: 19.03.3 Storage Driver: overlay2.......]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot+mybatis配置中遇到的问题]]></title>
    <url>%2F2019%2F10%2F05%2Fspringboot-mybatis%E9%85%8D%E7%BD%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[配置数据源123456789101112131415161718192021222324@Configuration@MapperScan("cn.ileehan.community.dao")public class DataSourceConfiguration &#123; @Value("$&#123;c3p0.driver&#125;") private String jdbcDriver; @Value("$&#123;c3p0.url&#125;") private String jdbcUrl; @Value("$&#123;c3p0.name&#125;") private String jdbcUsername; @Value("$&#123;c3p0.password&#125;") private String jdbcPassword; @Bean(name = "dataSource") public ComboPooledDataSource createDataSource() throws PropertyVetoException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(jdbcDriver); dataSource.setJdbcUrl(jdbcUrl); dataSource.setUser(jdbcUsername); dataSource.setPassword(jdbcPassword); // 关闭连接之后不自动commit dataSource.setAutoCommitOnClose(false); return dataSource; &#125;&#125; 配置SqlSessionFactoryBean123456789101112131415161718192021222324252627282930313233@Configurationpublic class SessionFactoryConfiguration &#123; @Value("$&#123;mapper.xml.config.path&#125;") private String mapperXMLConfigPath; @Value("$&#123;mapper.package.path&#125;") private String mapperPackagePath; @Value("$&#123;mapper.global.config&#125;") private String globalConfig; @Autowired private DataSource dataSource; @Bean public SqlSessionFactoryBean createSqlSessionFactory() throws IOException &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); // resource查找器可以查找类路径下或文件路径下的资源 PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); // mapperXML文件路径 String packageMapperXMLConfigPath = PathMatchingResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + mapperXMLConfigPath; // mybatis-config.xml路径 String globalConfigPath = PathMatchingResourcePatternResolver.CLASSPATH_URL_PREFIX + globalConfig; // 设置 mapper 对应的 XML 文件的路径 sqlSessionFactoryBean.setMapperLocations(resolver.getResources(packageMapperXMLConfigPath)); // 设置数据源 sqlSessionFactoryBean.setDataSource(dataSource); // 设置 mapper 接口所在的包 sqlSessionFactoryBean.setTypeAliasesPackage(mapperPackagePath); // 设置mybatis-config.xml，否则xml中全局配置将失效 sqlSessionFactoryBean.setConfigLocation(resolver.getResource(globalConfigPath)); return sqlSessionFactoryBean; &#125;&#125; 注意：在使用配置类配置SqlSessionFactoryBean时，要记得设置setConfigLocation #]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>SpringBoot</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2.5.x遇到的坑]]></title>
    <url>%2F2019%2F07%2F29%2FStruts2-5-x%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[通配符访问方法，报错404错误找不到页面报错截图 报错内容：There is no Action mapped for namespace [/] and action name [Emp_edit] associated with context path [/demo]. 错误原因：Struts2.5 为了提升安全性，默认开启了Strict Method Invocation（strict-method-invocation） 在SMI开启的情况下，通配符不会匹配所有的方法名，而是会匹配在default-struts.xml文件中global-allowed-methods属性所允许的方法名或者是匹配通过 &lt;allowed-method/&gt;标签来定义的方法名。 解决方法： ​ 方法一 在struts.xml中的package下添加regex:.*，匹配所有。 ​ 方法二 将package标签的属性strict-method-invocation设置为false。 默认全局允许匹配的方法名称： 动态匹配问题官方解释]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>-Struts2 -Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA导入mysql驱动，运行时找不到驱动包解决方案]]></title>
    <url>%2F2019%2F07%2F23%2FIDEA%E5%AF%BC%E5%85%A5mysql%E9%A9%B1%E5%8A%A8%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E9%A9%B1%E5%8A%A8%E5%8C%85%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[状况： 驱动导入了。 编译成功，运行报错： 解决办法 在WEB-INF目录下创建lib文件夹，将驱动包放入文件夹，并将lib文件设置为resources 再次添加驱动包就可以了]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>-Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyEclipse2017破解方法]]></title>
    <url>%2F2019%2F07%2F20%2FMyEclipse2017%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[方法安装包链接: https://pan.baidu.com/s/139Yc0FYVeKckEfgPMROhkQ 提取码: ilee 破解文件链接: https://pan.baidu.com/s/1eEn8nKAa07nnNnv_U-hnJw 提取码: ilee 首先配置好Java环境。 安装MyEclipse。 在安装最后一步，千万别点那个打开MyEclipse。 关闭安装界面后，把破解文件中的path里的所有文件拷贝进你的安装目录里的plugins，这里提醒你替换，选择替换。 替换完成后，再打开破解文件里myeclipse_keygen文件夹里的crack.bat，如果你发现点开闪退，这是你Java环境没有配置好的原因，去配置好你的Java环境，再运行crack.bat，出来一个界面。上面的空是你的用户名，这里自己起个名就ok，后面那个里面有很多版本，自己选择一个版本。 输好用户名，选择好版本，点一下systemid，再点一下systemid，然后点一下active，然后窗口下方会出现一堆东西例如这些： 12345678LICENSEE JerryLICENSE_KEY WLR8ZO-855555-7653625140119936ACTIVATION_CODE 11dFE23feaa1DBFE147730WLR8ZO-855555-7653625140119936210817ACTIVATION_KEY b5f7219363534b3fe8c02272c4cae4bff6621a5ceab73c4212c7e9e79fcf9ea5a5eedc9552a9901ef542ea90b474a6de64fe91b24b1e899982ff0a0152bb9ebae97efa69edd53ca90ccd85135f17a16571c297be4489108071870bf92d255f8dd95e01806d03727767b09e468dae9ac6c7a324126c026e483d0f20d2a231073d 看到这些，保留这个窗口，打开MyEclipse，打开后，选择active now，输入你的用户名和那个license key，然后，继续激活，选择我已经有激活文件（这里应该是英文，大家自己理解意思哈），输入activation_key下面那一大串的东西，然后激活就OK。 方法来源52破解]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射(Reflection) 学习笔记]]></title>
    <url>%2F2019%2F07%2F20%2Fjava%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、反射概述JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 (网图) 类加载过程： 二、Class类（包含完整的类的结构信息）Class对象由来：将class文件读入内存，并为之创建一个Class对象 Class 没有public 构造器。Class 对象是在加载类时由Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。 每个类（型）都有一个Class对象 Java基本类型和void都对应一个Class对象 每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。 1234567891011121314151617181920212223//每个数组属于被映射为 `Class` 对象的一个类，所有具有相同元素类型和维数的数组都共享该 `Class` 对象public class Demo3 &#123; public static void main(String[] args) &#123; String[] str = new String[3]; String[] str2 = new String[30]; String[][] str3 = new String[3][]; int[] in = new int[3]; int[][] in2 = new int[3][]; System.out.println("String一维数组:"+str.getClass().hashCode()); System.out.println("String一维数组（30）:"+str2.getClass().hashCode()); System.out.println("String二维数组:"+str3.getClass().hashCode()); System.out.println("int一维数组:"+in.getClass().hashCode()); System.out.println("int二维数组:"+in2.getClass().hashCode()); &#125;&#125; /*output String一维数组:460141958 String一维数组2:460141958 String二维数组:1163157884 int一维数组:1956725890 int二维数组:356573597 */ 1.获取Class对象方法123456789// 调用getClass方法MyObject x;Class clazz = x.getClass();//静态方法String path = "cn.ileehan.demo.User"Class clazz = Class.forName(path);// .classClass clazz = int.class;Class clazz1 = User.class; 2.Class类常用方法12newInstance(); // 创建实例，调用默认构造器getSuperclass(); // 返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class 1234567891011121314/*每种管理类型都是独一无二的Class对象，因此可以使用==来比较类对象if(e.getClass == Employee.class)....*/public class Demo4 &#123; public static void main(String[] args) &#123; Demo4 d = new Demo4(); if (d.getClass() == Demo4.class)&#123; System.out.println(true); &#125; &#125;&#125;//output:true 二、反射机制的常见作用UserInfo.java 1234567891011121314151617181920212223242526272829303132333435363738@ITable("t_talbe")public class UserInfo &#123; @IField(name = "id",type = "int",length = 6) private int id; @IField(name = "name",type = "varchar",length = 10) private String name; @IField(name = "age",type = "int",length = 3) private int age; public UserInfo(int id) &#123; this.id = id; &#125; public UserInfo() &#123;&#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 1.动态加载类、动态获取类的信息（属性、方法、构造器）获取属性信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* * 获取成员变量并调用： * * 1.批量的 * 1).Field[] getFields():获取所有的”公有字段” * 2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有； * 2.获取单个的： * 1).public Field getField(String fieldName):获取某个”公有的”字段； * 2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的) * * 设置字段的值： * Field –&gt; public void set(Object obj,Object value): * 参数说明： * 1.obj:要设置的字段所在的对象； * 2.value:要为字段设置的值； * */ // 获取属性得到的是Field对象public class Dem &#123; public static void main(String[] args) &#123; try &#123; // 动态加载类 Class clazz = Class.forName("cn.ileehan.bean.UserInfo"); // 获取属性信息 // Field field = clazz.getField("id"); // 只能获取指定名称的公开属性信息 // Field[] field = clazz.getFields(); // 获取所有公开属性的信息 Field[] fields = clazz.getDeclaredFields(); // 获取全部属性 包括公开与非公开 for (Field temp : fields) &#123; System.out.println("属性："+temp); &#125; Field f = clazz.getDeclaredField("id"); // 获取指定属性 包括公开与非公开 System.out.println("属性："+f); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*output属性：private int cn.ileehan.bean.UserInfo.id属性：private java.lang.String cn.ileehan.bean.UserInfo.name属性：private int cn.ileehan.bean.UserInfo.age属性：private int cn.ileehan.bean.UserInfo.id*/ 获取方法信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* * 获取成员方法并调用： * * 1.批量的： * public Method[] getMethods():获取所有”公有方法”；（包含了父类的方法也包含Object类） * public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的) * 2.获取单个的： * public Method getMethod(String name,Class&lt;?&gt;… parameterTypes): * 参数： * name : 方法名； * Class … : 形参的Class类型对象 * public Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes) * * 调用方法： * Method –&gt; public Object invoke(Object obj,Object… args): * 参数说明： * obj : 要调用方法的对象； * args:调用方式时所传递的实参； ): */ public class Dem &#123; public static void main(String[] args) &#123; try &#123; // 动态加载类 Class clazz = Class.forName("cn.ileehan.bean.UserInfo"); /* *只能获取公开方法，包括该类 继承 或者实现的接口 Method[] method = clazz.getMethods(); // 返回所有方法 for (Method temp : method) &#123; System.out.println("方法："+temp); &#125; Method m = clazz.getMethod("setId",int.class);// 获取指定方法 */ // all Method[] methods = clazz.getDeclaredMethods(); // 获取该类的所有方法 for (Method temp : methods) &#123; System.out.println("方法："+temp); &#125; Method m1 = clazz.getDeclaredMethod("getName"); // 获取无参方法 System.out.println("方法："+m1); Method m2 = clazz.getDeclaredMethod("setId",int.class); // 获取有参方法 System.out.println("方法："+m2); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*output方法：private java.lang.String cn.ileehan.bean.UserInfo.getName()方法：public int cn.ileehan.bean.UserInfo.getId()方法：public void cn.ileehan.bean.UserInfo.setName(java.lang.String)方法：public int cn.ileehan.bean.UserInfo.getAge()方法：public void cn.ileehan.bean.UserInfo.setAge(int)方法：public void cn.ileehan.bean.UserInfo.setId(int)方法：private java.lang.String cn.ileehan.bean.UserInfo.getName()方法：public void cn.ileehan.bean.UserInfo.setId(int)*/ 获取构造器信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员； * * 1.获取构造方法： * 1).批量的方法： * public Constructor[] getConstructors()：所有”公有的”构造方法 public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有) * 2).获取单个的方法，并调用： * public Constructor getConstructor(Class… parameterTypes):获取单个的”公有的”构造方法： * public Constructor getDeclaredConstructor(Class… parameterTypes):获取”某个构造方法”可以是私有的，或受保护、默认、公有； * * 调用构造方法： * Constructor–&gt;newInstance(Object… initargs) */ public class Dem &#123; public static void main(String[] args) &#123; try &#123; // 动态加载类 Class clazz = Class.forName("cn.ileehan.bean.UserInfo"); // 获取构造器信息 /* 必须是公开的 Constructor[] constructor = clazz.getConstructors(); // 获取所有公开构造器 for (Constructor temp : constructor) &#123; System.out.println("构造器："+temp); &#125; Constructor c = clazz.getConstructor(int.class); // 获取指定构造器传参数类型的类 System.out.println("构造器："+c); */ // 获取所有的构造器 公开与非公开 Constructor[] constructors = clazz.getDeclaredConstructors();//获取所有构造器 for (Constructor temp : constructors) &#123; System.out.println("构造器："+temp); &#125; Constructor c = clazz.getDeclaredConstructor(int.class);//获取指定参数类型的构造器 System.out.println("构造器："+c); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*output构造器：public cn.ileehan.bean.UserInfo(int)构造器：public cn.ileehan.bean.UserInfo()构造器：public cn.ileehan.bean.UserInfo(int)*/ 2.动态使用（属性、方法、构造器）1234567891011121314151617181920212223242526272829303132public class Demo2 &#123; public static void main(String[] args) &#123; String path = "cn.ileehan.bean.UserInfo"; try &#123; Class&lt;UserInfo&gt; clazz = (Class&lt;UserInfo&gt;) Class.forName(path); // 通过反射API调用构造器，构造对象 UserInfo u = clazz.newInstance(); // 实际上调用了UserInfo的无参构造方法 System.out.println(u); //指定参数类型 Constructor&lt;UserInfo&gt; constructor = clazz.getDeclaredConstructor(int.class); UserInfo us = constructor.newInstance(12);//实例化的时候要按照构造器要求传值 System.out.println(us.getId()); // 通过反射API调用方法 UserInfo u2 = clazz.newInstance(); Method m = clazz.getDeclaredMethod("setName", String.class); m.invoke(u2,"李四"); // 激活此方法 参数1-》哪里的方法 参数2-》按照方法的形参来 System.out.println(u2.getName()); // 通过反射API操作属性 UserInfo u3 = clazz.newInstance(); Field f = clazz.getDeclaredField("age"); f.setAccessible(true); // 允许操作private 不用做安全检查了，可以直接访问 f.set(u3,123); // 通过反射直接写属性 System.out.println(u3.getAge()); // 通过反射直接读属性的值 System.out.println(f.get(u3)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 3.反射main方法123456789101112131415161718192021public class Demo2 &#123; public static void main(String[] args) &#123; String path = "cn.ileehan.bean.UserInfo"; try &#123; //获取UserInfo对象字节码 Class&lt;UserInfo&gt; clazz = (Class&lt;UserInfo&gt;) Class.forName(path); //获取main方法 Method methodMain = clazz.getMethod("main",String[].class); //调用main方法 methodMain.invoke(null, (Object)new String[]&#123;"a","b","c"&#125;); /* 必须要加上(Object) 否则编译器会编译成 methodMain.invoke(null, "a","b","c"); */ &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 4.反射注解12345678910111213141516171819202122232425262728293031public class Demo &#123; public static void main(String[] args) &#123; try &#123; //获取UserInfo的class对象 Class cl = Class.forName("cn.ileehan.bean.UserInfo"); // 获得类的所有注解 Annotation[] annotations = cl.getAnnotations(); for (Annotation a : annotations) &#123; System.out.println(a); &#125; // 获得类的指定注解 ITable table = (ITable) cl.getAnnotation(ITable.class); // 转成注解类型 System.out.println(table.value()); // 获得类的属性的注解 Field na = cl.getDeclaredField("name"); // 通过反射获取指定属性 IField ie = na.getAnnotation(IField.class); System.out.println(ie.name()+"---"+ie.type()+"---"+ie.length()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*output@cn.ileehan.annotation.ITable(value=t_talbe)t_talbename---varchar---10*/ 5.通过反射越过泛型检查1234567891011121314151617181920212223242526// 想Sting泛型的集合，添加Integer类型的值public class Demo &#123; public static void main(String[] args) throws Exception&#123; ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add("aaa"); strList.add("bbb"); // strList.add(100); //获取ArrayList的Class对象，反向的调用add()方法，添加数据 Class listClass = strList.getClass(); //得到 strList 对象的字节码 对象 //获取add()方法 Method m = listClass.getMethod("add", Object.class); //调用add()方法 m.invoke(strList, 100); //遍历集合 for(Object obj : strList)&#123; System.out.println(obj); &#125; &#125; &#125; /*outputaaabbb100*/ 参考文章：java反射（特别通俗易懂）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 注解 学习笔记]]></title>
    <url>%2F2019%2F07%2F19%2Fjava%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、注解格式注解格式格式：@注释名/ @注释名(value) 例如： 1@SuppressWaring("all") 二、内置注解1@Override // 用于修饰方法，表示重写 1@Deprecated // 可修饰方法 属性 类， 表示此方法弃用（不是不能用） 1@SuppressWarings // 抑制编译时的警告信息 参数 说明 deprecation 使用了过时的类或方法的警告 unchecked 执行了为检查的转换。eg:使用集合未指定泛型 fallthrough switch发生case穿透 path 资源或类路径不存在 serial 当前可序列化类上缺少serialVersionUID定义时的警告 finally 任何finally子句不能完成时的警告 all 关于以上的所有警告 eg: 12@SuppressWarings("fallthrough")@SuppressWarings(value = &#123;"unchecked","deprecation"&#125;) 三、自定义注解例子 123456789/*元注解public @interface 注解名｛注解体｝*/@Target(value = &#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface IField &#123; String name();&#125; 1.基本语法注解类型的声明部分： 注解在Java中，与类、接口、枚举类似，因此其声明语法基本一致，只是所使用的关键字有所不同@interface。在底层实现上，所有定义的注解都会自动继承java.lang.annotation.Annotation接口。 12public @interface IField &#123;&#125; 注解类型元素： 12345public @interface IField &#123; String name(); int age() default 12; int[] array();&#125; :warning:注意 该元素的类型只能是基本数据类型、Class、String、enum、注解类型以及上述类型的一位数组 若注解中只有一个元素，则将其命名为value（方便，在使用时可省略参数名） ()仅是特殊语法，不代表他是方法 如果没有默认值，使用时必须要给该类型元素赋值 定义注解时常用空字符串、0做默认值，可使用-1表示不存在 2.元注解元注解：专门修饰注解的注解 2.1 @Target用于描述注解的使用范围（注解用在什么位置上） 所修饰范围 取值ElementType package包 PACKAGE 类、接口、枚举、注解类型 TYPE 类成员(方法、构造方法、成员变量、枚举值) CONSTRUCTOR:描述构造器FIELD：用于描述成员变量METHOD:描述方法 方法参数和局部变量 LOCAL_VARIABLE:描述局部变量PARAMETER:描述参数 123456//@CherryAnnotation被限定只能使用在类、接口或方法上面@Target(value = &#123;ElementType.TYPE,ElementType.METHOD&#125;)public @interface CherryAnnotation &#123; String name(); &#125; 2.2 @Retention用于描述注解的生命周期 取值RetentionPolicy 作用 SOURCE 在源文件中有效（给人看的） CLASS 在class文件中有效（JVM忽略它） RUNTIME 在运行时有效，此时可以被反射机制读取 1234@Retention(RetentionPolicy.RUNTIME) // 运行时有效public @interface IField &#123; String name();&#125; 默认情况下，自定义注解使用的是RetentionPolicy.CLASS 四、反射机制读取注解信息Demo.java 12345678910111213141516171819202122232425262728293031public class Demo &#123; public static void main(String[] args) &#123; try &#123; //获取UserInfo的class对象 Class cl = Class.forName("cn.ileehan.bean.UserInfo"); // 获得类的所有注解 Annotation[] annotations = cl.getAnnotations(); for (Annotation a : annotations) &#123; System.out.println(a); &#125; // 获得类的指定注解 ITable table = (ITable) cl.getAnnotation(ITable.class); System.out.println(table.value()); // 获得类的属性的注解 Field na = cl.getDeclaredField("name"); // 通过反射获取指定属性 IField ie = na.getAnnotation(IField.class); System.out.println(ie.name()+"---"+ie.type()+"---"+ie.length()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*output@cn.ileehan.annotation.ITable(value=t_talbe)t_talbename---varchar---10*/ ITable.java 12345@Target(value = &#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ITable &#123; String value();&#125; IField.java 1234567@Target(value = &#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface IField &#123; String name(); String type(); int length();&#125; UserInfo.java 12345678910@ITable("t_talbe")public class UserInfo &#123; @IField(name = "id",type = "int",length = 6) private int id; @IField(name = "name",type = "varchar",length = 10) private String name; @IField(name = "age",type = "int",length = 3) private int age;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
