<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 反射(Reflection) 学习笔记]]></title>
    <url>%2F2019%2F07%2F20%2Fjava%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、反射概述JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 (网图) 类加载过程： 二、Class类（包含完整的类的结构信息）Class对象由来：将class文件读入内存，并为之创建一个Class对象 Class 没有public 构造器。Class 对象是在加载类时由Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。 每个类（型）都有一个Class对象 Java基本类型和void都对应一个Class对象 每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。 1234567891011121314151617181920212223//每个数组属于被映射为 `Class` 对象的一个类，所有具有相同元素类型和维数的数组都共享该 `Class` 对象public class Demo3 &#123; public static void main(String[] args) &#123; String[] str = new String[3]; String[] str2 = new String[30]; String[][] str3 = new String[3][]; int[] in = new int[3]; int[][] in2 = new int[3][]; System.out.println("String一维数组:"+str.getClass().hashCode()); System.out.println("String一维数组（30）:"+str2.getClass().hashCode()); System.out.println("String二维数组:"+str3.getClass().hashCode()); System.out.println("int一维数组:"+in.getClass().hashCode()); System.out.println("int二维数组:"+in2.getClass().hashCode()); &#125;&#125; /*output String一维数组:460141958 String一维数组2:460141958 String二维数组:1163157884 int一维数组:1956725890 int二维数组:356573597 */ 1.获取Class对象方法123456789// 调用getClass方法MyObject x;Class clazz = x.getClass();//静态方法String path = "cn.ileehan.demo.User"Class clazz = Class.forName(path);// .classClass clazz = int.class;Class clazz1 = User.class; 2.Class类常用方法12newInstance(); // 创建实例，调用默认构造器getSuperclass(); // 返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class 1234567891011121314/*每种管理类型都是独一无二的Class对象，因此可以使用==来比较类对象if(e.getClass == Employee.class)....*/public class Demo4 &#123; public static void main(String[] args) &#123; Demo4 d = new Demo4(); if (d.getClass() == Demo4.class)&#123; System.out.println(true); &#125; &#125;&#125;//output:true 二、反射机制的常见作用UserInfo.java 1234567891011121314151617181920212223242526272829303132333435363738@ITable("t_talbe")public class UserInfo &#123; @IField(name = "id",type = "int",length = 6) private int id; @IField(name = "name",type = "varchar",length = 10) private String name; @IField(name = "age",type = "int",length = 3) private int age; public UserInfo(int id) &#123; this.id = id; &#125; public UserInfo() &#123;&#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 1.动态加载类、动态获取类的信息（属性、方法、构造器）获取属性信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* * 获取成员变量并调用： * * 1.批量的 * 1).Field[] getFields():获取所有的”公有字段” * 2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有； * 2.获取单个的： * 1).public Field getField(String fieldName):获取某个”公有的”字段； * 2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的) * * 设置字段的值： * Field –&gt; public void set(Object obj,Object value): * 参数说明： * 1.obj:要设置的字段所在的对象； * 2.value:要为字段设置的值； * */ // 获取属性得到的是Field对象public class Dem &#123; public static void main(String[] args) &#123; try &#123; // 动态加载类 Class clazz = Class.forName("cn.ileehan.bean.UserInfo"); // 获取属性信息 // Field field = clazz.getField("id"); // 只能获取指定名称的公开属性信息 // Field[] field = clazz.getFields(); // 获取所有公开属性的信息 Field[] fields = clazz.getDeclaredFields(); // 获取全部属性 包括公开与非公开 for (Field temp : fields) &#123; System.out.println("属性："+temp); &#125; Field f = clazz.getDeclaredField("id"); // 获取指定属性 包括公开与非公开 System.out.println("属性："+f); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*output属性：private int cn.ileehan.bean.UserInfo.id属性：private java.lang.String cn.ileehan.bean.UserInfo.name属性：private int cn.ileehan.bean.UserInfo.age属性：private int cn.ileehan.bean.UserInfo.id*/ 获取方法信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* * 获取成员方法并调用： * * 1.批量的： * public Method[] getMethods():获取所有”公有方法”；（包含了父类的方法也包含Object类） * public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的) * 2.获取单个的： * public Method getMethod(String name,Class&lt;?&gt;… parameterTypes): * 参数： * name : 方法名； * Class … : 形参的Class类型对象 * public Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes) * * 调用方法： * Method –&gt; public Object invoke(Object obj,Object… args): * 参数说明： * obj : 要调用方法的对象； * args:调用方式时所传递的实参； ): */ public class Dem &#123; public static void main(String[] args) &#123; try &#123; // 动态加载类 Class clazz = Class.forName("cn.ileehan.bean.UserInfo"); /* *只能获取公开方法，包括该类 继承 或者实现的接口 Method[] method = clazz.getMethods(); // 返回所有方法 for (Method temp : method) &#123; System.out.println("方法："+temp); &#125; Method m = clazz.getMethod("setId",int.class);// 获取指定方法 */ // all Method[] methods = clazz.getDeclaredMethods(); // 获取该类的所有方法 for (Method temp : methods) &#123; System.out.println("方法："+temp); &#125; Method m1 = clazz.getDeclaredMethod("getName"); // 获取无参方法 System.out.println("方法："+m1); Method m2 = clazz.getDeclaredMethod("setId",int.class); // 获取有参方法 System.out.println("方法："+m2); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*output方法：private java.lang.String cn.ileehan.bean.UserInfo.getName()方法：public int cn.ileehan.bean.UserInfo.getId()方法：public void cn.ileehan.bean.UserInfo.setName(java.lang.String)方法：public int cn.ileehan.bean.UserInfo.getAge()方法：public void cn.ileehan.bean.UserInfo.setAge(int)方法：public void cn.ileehan.bean.UserInfo.setId(int)方法：private java.lang.String cn.ileehan.bean.UserInfo.getName()方法：public void cn.ileehan.bean.UserInfo.setId(int)*/ 获取构造器信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员； * * 1.获取构造方法： * 1).批量的方法： * public Constructor[] getConstructors()：所有”公有的”构造方法 public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有) * 2).获取单个的方法，并调用： * public Constructor getConstructor(Class… parameterTypes):获取单个的”公有的”构造方法： * public Constructor getDeclaredConstructor(Class… parameterTypes):获取”某个构造方法”可以是私有的，或受保护、默认、公有； * * 调用构造方法： * Constructor–&gt;newInstance(Object… initargs) */ public class Dem &#123; public static void main(String[] args) &#123; try &#123; // 动态加载类 Class clazz = Class.forName("cn.ileehan.bean.UserInfo"); // 获取构造器信息 /* 必须是公开的 Constructor[] constructor = clazz.getConstructors(); // 获取所有公开构造器 for (Constructor temp : constructor) &#123; System.out.println("构造器："+temp); &#125; Constructor c = clazz.getConstructor(int.class); // 获取指定构造器传参数类型的类 System.out.println("构造器："+c); */ // 获取所有的构造器 公开与非公开 Constructor[] constructors = clazz.getDeclaredConstructors();//获取所有构造器 for (Constructor temp : constructors) &#123; System.out.println("构造器："+temp); &#125; Constructor c = clazz.getDeclaredConstructor(int.class);//获取指定参数类型的构造器 System.out.println("构造器："+c); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*output构造器：public cn.ileehan.bean.UserInfo(int)构造器：public cn.ileehan.bean.UserInfo()构造器：public cn.ileehan.bean.UserInfo(int)*/ 2.动态使用（属性、方法、构造器）1234567891011121314151617181920212223242526272829303132public class Demo2 &#123; public static void main(String[] args) &#123; String path = "cn.ileehan.bean.UserInfo"; try &#123; Class&lt;UserInfo&gt; clazz = (Class&lt;UserInfo&gt;) Class.forName(path); // 通过反射API调用构造器，构造对象 UserInfo u = clazz.newInstance(); // 实际上调用了UserInfo的无参构造方法 System.out.println(u); //指定参数类型 Constructor&lt;UserInfo&gt; constructor = clazz.getDeclaredConstructor(int.class); UserInfo us = constructor.newInstance(12);//实例化的时候要按照构造器要求传值 System.out.println(us.getId()); // 通过反射API调用方法 UserInfo u2 = clazz.newInstance(); Method m = clazz.getDeclaredMethod("setName", String.class); m.invoke(u2,"李四"); // 激活此方法 参数1-》哪里的方法 参数2-》按照方法的形参来 System.out.println(u2.getName()); // 通过反射API操作属性 UserInfo u3 = clazz.newInstance(); Field f = clazz.getDeclaredField("age"); f.setAccessible(true); // 允许操作private 不用做安全检查了，可以直接访问 f.set(u3,123); // 通过反射直接写属性 System.out.println(u3.getAge()); // 通过反射直接读属性的值 System.out.println(f.get(u3)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 3.反射main方法12345678910111213141516public class Demo2 &#123; public static void main(String[] args) &#123; String path = "cn.ileehan.bean.UserInfo"; try &#123; //获取UserInfo对象字节码 Class&lt;UserInfo&gt; clazz = (Class&lt;UserInfo&gt;) Class.forName(path); //获取main方法 Method methodMain = clazz.getMethod("main",String[].class); //调用main方法 明确告诉编译器，这个数组是一个参数 methodMain.invoke(null, (Object)new String[]&#123;"a","b","c"&#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 4.反射注解12345678910111213141516171819202122232425262728293031public class Demo &#123; public static void main(String[] args) &#123; try &#123; //获取UserInfo的class对象 Class cl = Class.forName("cn.ileehan.bean.UserInfo"); // 获得类的所有注解 Annotation[] annotations = cl.getAnnotations(); for (Annotation a : annotations) &#123; System.out.println(a); &#125; // 获得类的指定注解 ITable table = (ITable) cl.getAnnotation(ITable.class); // 转成注解类型 System.out.println(table.value()); // 获得类的属性的注解 Field na = cl.getDeclaredField("name"); // 通过反射获取指定属性 IField ie = na.getAnnotation(IField.class); System.out.println(ie.name()+"---"+ie.type()+"---"+ie.length()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*output@cn.ileehan.annotation.ITable(value=t_talbe)t_talbename---varchar---10*/ 5.通过反射越过泛型检查1234567891011121314151617181920212223242526// 想Sting泛型的集合，添加Integer类型的值public class Demo &#123; public static void main(String[] args) throws Exception&#123; ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add("aaa"); strList.add("bbb"); // strList.add(100); //获取ArrayList的Class对象，反向的调用add()方法，添加数据 Class listClass = strList.getClass(); //得到 strList 对象的字节码 对象 //获取add()方法 Method m = listClass.getMethod("add", Object.class); //调用add()方法 m.invoke(strList, 100); //遍历集合 for(Object obj : strList)&#123; System.out.println(obj); &#125; &#125; &#125; /*outputaaabbb100*/ 参考文章：java反射（特别通俗易懂）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 注解 学习笔记]]></title>
    <url>%2F2019%2F07%2F19%2Fjava%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、注解格式注解格式格式：@注释名/ @注释名(value) 例如： 1@SuppressWaring("all") 二、内置注解1@Override // 用于修饰方法，表示重写 1@Deprecated // 可修饰方法 属性 类， 表示此方法弃用（不是不能用） 1@SuppressWarings // 抑制编译时的警告信息 参数 说明 deprecation 使用了过时的类或方法的警告 unchecked 执行了为检查的转换。eg:使用集合未指定泛型 fallthrough switch发生case穿透 path 资源或类路径不存在 serial 当前可序列化类上缺少serialVersionUID定义时的警告 finally 任何finally子句不能完成时的警告 all 关于以上的所有警告 eg: 12@SuppressWarings("fallthrough")@SuppressWarings(value = &#123;"unchecked","deprecation"&#125;) 三、自定义注解例子 123456789/*元注解public @interface 注解名｛注解体｝*/@Target(value = &#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface IField &#123; String name();&#125; 1.基本语法注解类型的声明部分： 注解在Java中，与类、接口、枚举类似，因此其声明语法基本一致，只是所使用的关键字有所不同@interface。在底层实现上，所有定义的注解都会自动继承java.lang.annotation.Annotation接口。 12public @interface IField &#123;&#125; 注解类型元素： 12345public @interface IField &#123; String name(); int age() default 12; int[] array();&#125; :warning:注意 该元素的类型只能是基本数据类型、Class、String、enum、注解类型以及上述类型的一位数组 若注解中只有一个元素，则将其命名为value（方便，在使用时可省略参数名） ()仅是特殊语法，不代表他是方法 如果没有默认值，使用时必须要给该类型元素赋值 定义注解时常用空字符串、0做默认值，可使用-1表示不存在 2.元注解元注解：专门修饰注解的注解 2.1 @Target用于描述注解的使用范围（注解用在什么位置上） 所修饰范围 取值ElementType package包 PACKAGE 类、接口、枚举、注解类型 TYPE 类成员(方法、构造方法、成员变量、枚举值) CONSTRUCTOR:描述构造器FIELD：用于描述成员变量METHOD:描述方法 方法参数和局部变量 LOCAL_VARIABLE:描述局部变量PARAMETER:描述参数 123456//@CherryAnnotation被限定只能使用在类、接口或方法上面@Target(value = &#123;ElementType.TYPE,ElementType.METHOD&#125;)public @interface CherryAnnotation &#123; String name(); &#125; 2.2 @Retention用于描述注解的生命周期 取值RetentionPolicy 作用 SOURCE 在源文件中有效（给人看的） CLASS 在class文件中有效（JVM忽略它） RUNTIME 在运行时有效，此时可以被反射机制读取 1234@Retention(RetentionPolicy.RUNTIME) // 运行时有效public @interface IField &#123; String name();&#125; 默认情况下，自定义注解使用的是RetentionPolicy.CLASS 四、反射机制读取注解信息Demo.java 12345678910111213141516171819202122232425262728293031public class Demo &#123; public static void main(String[] args) &#123; try &#123; //获取UserInfo的class对象 Class cl = Class.forName("cn.ileehan.bean.UserInfo"); // 获得类的所有注解 Annotation[] annotations = cl.getAnnotations(); for (Annotation a : annotations) &#123; System.out.println(a); &#125; // 获得类的指定注解 ITable table = (ITable) cl.getAnnotation(ITable.class); System.out.println(table.value()); // 获得类的属性的注解 Field na = cl.getDeclaredField("name"); // 通过反射获取指定属性 IField ie = na.getAnnotation(IField.class); System.out.println(ie.name()+"---"+ie.type()+"---"+ie.length()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*output@cn.ileehan.annotation.ITable(value=t_talbe)t_talbename---varchar---10*/ ITable.java 12345@Target(value = &#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ITable &#123; String value();&#125; IField.java 1234567@Target(value = &#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface IField &#123; String name(); String type(); int length();&#125; UserInfo.java 12345678910@ITable("t_talbe")public class UserInfo &#123; @IField(name = "id",type = "int",length = 6) private int id; @IField(name = "name",type = "varchar",length = 10) private String name; @IField(name = "age",type = "int",length = 3) private int age;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
